<?php

namespace App\Providers;

use Illuminate\Support\ServiceProvider;
use Illuminate\Support\Facades\File;
use Illuminate\Support\Str;

class RepositoryServiceProvider extends ServiceProvider
{
    /**
     * Registra los binding de los repositorios.
     *
     * @return void
     */
    public function register()
    {
        // Aquí puedes registrar manualmente los bindings personalizados de tus repositorios
        // Ejemplo:
        // $this->app->bind(
        //     \App\Repositories\Contracts\UserRepositoryInterface::class,
        //     \App\Repositories\UserRepository::class
        // );
        
        // Alternativamente, puedes crear un método para registrar automáticamente todos
        // los repositorios que siguen la convención de nombres:
        // $this->registerRepositories();
    }

    /**
     * Bootstrap services.
     *
     * @return void
     */
    public function boot()
    {
        //
    }

    /**
     * Registra automáticamente los repositorios y sus interfaces.
     * 
     * @return void
     */
    protected function registerRepositories()
    {
        $basePath = app_path('Repositories');

        if (!File::exists($basePath)) {
            return;
        }

        foreach (File::allFiles($basePath) as $file) {
            // Omitir directorios de contratos
            if (Str::contains($file->getRelativePath(), 'Contracts')) {
                continue;
            }

            // Procesar solo archivos PHP
            if ($file->getExtension() !== 'php') {
                continue;
            }

            // Obtener el nombre completo de la clase
            $class = $this->getClassFromPath($file->getPathname());

            // Omitir si la clase no existe o no termina con Repository
            if (!class_exists($class) || 
                !Str::endsWith($class, 'Repository') || 
                $class === 'App\\Repositories\\BaseRepository') {
                continue;
            }

            // Verificar si la clase es abstracta
            try {
                $reflectionClass = new \ReflectionClass($class);
                if ($reflectionClass->isAbstract()) {
                    continue;
                }
            } catch (\ReflectionException $e) {
                continue;
            }

            // Construir el nombre de la interfaz
            $interface = $this->buildInterfaceName($class);

            // Enlazar si la interfaz existe
            if (interface_exists($interface)) {
                $this->app->bind($interface, $class);
            }
        }
    }

    /**
     * Obtiene el nombre completamente cualificado de la clase desde la ruta del archivo.
     * 
     * @param string $path Ruta del archivo
     * @return string Nombre completamente cualificado de la clase
     */
    protected function getClassFromPath($path)
    {
        $appPath = app_path();
        $relativePath = Str::after($path, $appPath . DIRECTORY_SEPARATOR);
        $relativePath = str_replace('.php', '', $relativePath);
        $namespace = str_replace(DIRECTORY_SEPARATOR, '\\', $relativePath);

        return 'App\\' . $namespace;
    }

    /**
     * Construye el nombre de la interfaz basado en el nombre de la clase del repositorio.
     * 
     * @param string $class Nombre completamente cualificado de la clase
     * @return string Nombre completamente cualificado de la interfaz
     */
    protected function buildInterfaceName($class)
    {
        $baseName = class_basename($class);
        $namespace = Str::beforeLast($class, '\\' . $baseName);
        
        // Construir el nombre de la interfaz sustituyendo 'Repository' por 'RepositoryInterface'
        $interfaceName = Str::endsWith($baseName, 'Repository') 
            ? Str::replaceLast('Repository', 'RepositoryInterface', $baseName)
            : $baseName . 'Interface';

        // Reemplazar 'Repositories' por 'Repositories\Contracts' en el namespace
        return str_replace('Repositories\\', 'Repositories\\Contracts\\', $namespace) . '\\' . $interfaceName;
    }
}
